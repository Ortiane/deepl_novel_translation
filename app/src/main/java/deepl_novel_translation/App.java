/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package deepl_novel_translation;

import com.dropbox.core.DbxException;
import com.dropbox.core.DbxRequestConfig;
import com.dropbox.core.v2.DbxClientV2;
import com.dropbox.core.v2.files.ListFolderResult;
import com.dropbox.core.v2.files.Metadata;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import javax.annotation.Nullable;

public class App {

    private static final String ACCESS_TOKEN = System.getenv("ACCESS_TOKEN");
    private ConcurrentLinkedQueue<String> chapters = new ConcurrentLinkedQueue<String>();
    private ConcurrentLinkedQueue<String> translated = new ConcurrentLinkedQueue<String>();
    private DbxClientV2 client;
    private final int TRANSLATION_CONSUMER_THREADS = 2;
    private final int DOWNLOAD_CONSUMER_THREADS = 10;

    private @Nullable ListFolderResult getDropboxListFolderResult(DbxClientV2 client, String novelName) {
        ListFolderResult result = null;
        try {
            result = client.files().listFolder("/" + novelName);
        } catch (DbxException e) {
            System.out.println(String.format("Issue pulling folder %s: %s", novelName, e.getMessage()));
        }
        return result;
    }

    public void instantiateDropboxClient(String clientIdentifier) {
        // Create Dropbox client
        DbxRequestConfig config = DbxRequestConfig.newBuilder(clientIdentifier).build();
        this.client = new DbxClientV2(config, ACCESS_TOKEN);
        return;
    }

    public ArrayList<String> getNovelChapters(String novelName) {
        ListFolderResult result = this.getDropboxListFolderResult(this.client, novelName);
        ArrayList<String> chaptersList = new ArrayList<String>();
        while (result != null) {
            for (Metadata metadata : result.getEntries()) {
                String path = metadata.getPathDisplay();
                if (path.endsWith(".txt")) {
                    chaptersList.add(path);
                }
            }

            if (!result.getHasMore()) {
                break;
            }
            try {
                result = this.client.files().listFolderContinue(result.getCursor());
            } catch (DbxException e) {
                break;
            }
        }
        return chaptersList;
    }

    public void executeTranslatorConsumers() {
        ExecutorService executor = Executors.newFixedThreadPool(TRANSLATION_CONSUMER_THREADS);
        LinkedList<Future<?>> tasks = new LinkedList<Future<?>>();
        for (int i = 0; i < TRANSLATION_CONSUMER_THREADS; i++) {
            Future<?> future = executor.submit(new TranslationConsumer(this.chapters, this.translated));
            tasks.add(future);
        }
        for (Future<?> future : tasks) {
            try {
                future.get();
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }
        executor.shutdown();
    }

    public void executeDownloadConsumers(List<String> chaptersList) {
        ExecutorService executor = Executors.newFixedThreadPool(DOWNLOAD_CONSUMER_THREADS);
        LinkedList<Future<?>> tasks = new LinkedList<Future<?>>();
        ConcurrentLinkedQueue<String> chaptersQueue = new ConcurrentLinkedQueue<String>(chaptersList);
        for (int i = 0; i < DOWNLOAD_CONSUMER_THREADS; i++) {
            Future<?> future = executor.submit(new DownloadConsumer(chaptersQueue, this.chapters, this.client));
            tasks.add(future);
        }
        for (Future<?> future : tasks) {
            try {
                future.get();
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }
        executor.shutdown();
    }

    public void writeChaptersToDirectory(String directoryPath) {

        File directory = new File(directoryPath);

        // Create the directory if it does not exist
        if (!directory.exists()) {
            directory.mkdirs();
        }

        while (!this.translated.isEmpty()) {
            String chapter = this.translated.poll();
            int titleEndPostion = chapter.indexOf("\n");
            String fileName = chapter.substring(chapter.lastIndexOf("/"), titleEndPostion);
            String translatedText = chapter.substring(titleEndPostion + 1);
            try {
                File file = new File(directory, fileName);

                FileWriter writer = new FileWriter(file);
                writer.write(translatedText);
                writer.close();
            } catch (IOException e) {
                System.out.println("An error occurred writing file: " + fileName);
                e.printStackTrace();
            }
        }
    }

    public static void main(String args[]) {
        if (args.length != 3) {
            System.out.println(
                    "Needs exactly 3 arguments to run:\n"
                            + "1. The client identifier for dropbox (likely the project folder)\n"
                            + "2. The directory in dropbox which holds the novel.\n"
                            + "3. The local save directory name");
            return;
        }
        String clientIdentifier = args[1];
        String novelDropBoxDirectoryPath = args[1];
        String directoryPath = args[2];
        App app = new App();
        app.instantiateDropboxClient(clientIdentifier);
        ArrayList<String> chaptersList = app.getNovelChapters(novelDropBoxDirectoryPath);
        app.executeDownloadConsumers(chaptersList);
        app.executeTranslatorConsumers();
        app.writeChaptersToDirectory(directoryPath);
        System.out.println("Completed Translations");
    }
}
